
#' Apply the Constant Rate of Supply or Constant Initial Concentration model
#'
#' @param cumulative_dry_mass The cumulative dry mass of the core (in kg), starting at the
#'   surface sample and including all samples in the core.
#'   These must be greater than 0 and in increasing order.
#' @param excess_pb210 An excess (non-erosional) lead-210 specific activity (in Bq/kg)
#'   for samples where this was measured, and NA where lead-210 was not measured. Use
#'   [errors::set_errors()] to use automatic error propogation.
#' @param inventory The cumulative excess lead-210 activity (in Bq), starting at the bottom
#'   of the core. By default, this is estimated by the default [pb210_inventory_calculator()].
#' @param model_top A fit object, such as one generated by [pb210_fit_exponential()], or a
#'   constant specifying the surface concentration (CIC model) or inventory (CRS model).
#'   The choice of this value has considerable impact on young dates.
#' @param core_area The internal area of the corer (in m^2^). This can be calculated
#'   from an internal diameter using [pb210_core_area()].
#' @param decay_constant The decay contstant for lead-210 (in 1/years). This is an argument
#'   rather than a constant because we have found that different spreadsheets in the wild
#'   use different decay constants. See [pb210_decay_constant()].
#' @param object A fit object generated by [pb210_crs()] or [pb210_cic()].
#' @param ... Unused.
#'
#' @references
#' Appleby, P.G., and Oldfield, F. 1983. The assessment of ^210^Pb data from sites with
#' varying sediment accumulation rates.
#' Hydrobiologia, 103: 29–35. doi:10.1007/BF00028424.
#'
#' Appleby, P.G., and Oldfield, F. 1978. The calculation of lead-210 dates assuming a
#' constant rate of supply of unsupported ^210^Pb to the sediment.
#' CATENA, 5: 1–8. doi:10.1016/S0341-8162(78)80002-2.
#'
#' @return `predict()` methods return a tibble with (at least)
#' components `age` and `age_sd` (both in years).
#'   CRS model `predict()` function output also contains `inventory`, `inventory_sd`,
#'   `mar` and `mar_sd` (in kg / m^2^ / year).
#' @export
#'
#' @examples
#' # simulate a core
#' core <- pb210_simulate_accumulation(
#'   mass_accumulation = pb210_mass_accumulation_constant()
#' ) %>%
#'   pb210_simulate_core() %>%
#'   pb210_simulate_counting()
#'
#' # calculate ages using the CIC model
#' cic <- pb210_cic(
#'   pb210_cumulative_mass(core$slice_mass, position = 0.5),
#'   set_errors(
#'     core$pb210_specific_activity_estimate,
#'     core$pb210_specific_activity_se
#'   )
#' )
#'
#' predict(cic)
#'
#' # calculate ages using the CRS model
#' crs <- pb210_crs(
#'   pb210_cumulative_mass(core$slice_mass),
#'   set_errors(
#'     core$pb210_specific_activity_estimate,
#'     core$pb210_specific_activity_se
#'   )
#' )
#'
#' predict(crs)
#'
pb210_cic <- function(cumulative_dry_mass, excess_pb210,
                      model_top = ~pb210_fit_exponential(..1, ..2),
                      decay_constant = pb210_decay_constant()) {
  check_mass_and_activity(cumulative_dry_mass, without_errors(excess_pb210))
  stopifnot(
    is.numeric(decay_constant), length(decay_constant) == 1,
    without_errors(decay_constant) > 0
  )

  # validate the top model fit, combine errors for pb210
  model_top <- pb210_as_fit(model_top)

  # capture relevant info
  structure(
    list(
      data = tibble::tibble(
        cumulative_dry_mass = cumulative_dry_mass,
        excess_pb210 = with_errors(excess_pb210)
      ),
      model_top = model_top,
      decay_constant = with_errors(decay_constant)
    ),
    class = c("pb210_fit_cic", "pb210_fit")
  )
}

#' @rdname pb210_cic
#' @export
pb210_crs <- function(cumulative_dry_mass, excess_pb210,
                      inventory = pb210_inventory_calculator(),
                      model_top = ~pb210_fit_exponential(..1, ..2),
                      core_area = pb210_core_area(),
                      decay_constant = pb210_decay_constant()) {

  check_mass_and_activity(cumulative_dry_mass, without_errors(excess_pb210))
  stopifnot(
    inherits(inventory, "inventory_calculator") || is.numeric(inventory),
    length(core_area) == 1, is.numeric(core_area),
    length(decay_constant) == 1, is.numeric(decay_constant)
  )

  if (is.numeric(inventory)) {
    stopifnot(length(inventory) == length(cumulative_dry_mass))
    inventory <- with_errors(inventory)
  }

  # capture relevant info
  structure(
    list(
      data = tibble::tibble(
        cumulative_dry_mass = cumulative_dry_mass,
        excess_pb210 = with_errors(excess_pb210)
      ),
      # inventory could be an inventory calculator
      inventory = inventory,
      model_top = pb210_as_fit(model_top),
      core_area = with_errors(core_area),
      decay_constant = with_errors(decay_constant)
    ),
    class = c("pb210_fit_crs", "pb210_fit")
  )
}

#' @rdname pb210_cic
#' @export
predict.pb210_fit_cic <- function(object, cumulative_dry_mass = NULL, ...) {
  if (is.null(cumulative_dry_mass)) {
    cumulative_dry_mass <- object$data$cumulative_dry_mass
  }

  excess_pb210 <- stats::approx(
    object$data$cumulative_dry_mass,
    without_errors(object$data$excess_pb210),
    xout = cumulative_dry_mass
  )$y

  # use errors for exact matches of cumulative_dry_mass to the original
  original_matches <- match(cumulative_dry_mass, object$data$cumulative_dry_mass)
  excess_pb210_sd <- extract_errors(object$data$excess_pb210)[original_matches]

  # assign errors
  excess_pb210 <- with_errors(excess_pb210, excess_pb210_sd)

  # resolve the top model
  model_top <- pb210_as_fit(
    object$model_top,
    data = tibble::tibble(cumulative_dry_mass, excess_pb210)
  )
  surface_excess_pb210 <- with_errors(stats::predict(model_top, tibble::tibble(x = 0)))

  # calculate ages
  age <- with_errors(1) / object$decay_constant * log(surface_excess_pb210 / excess_pb210)
  age_sd <- extract_errors(age)
  has_error <- is.finite(errors(excess_pb210)) & (errors(excess_pb210) > 0)
  age_sd[!has_error] <- NA_real_

  tibble::tibble(
    age = without_errors(age),
    age_sd = age_sd
  )
}

#' @rdname pb210_cic
#' @export
predict.pb210_fit_crs <- function(object, cumulative_dry_mass = NULL, ...) {
  if (is.null(cumulative_dry_mass)) {
    cumulative_dry_mass <- object$data$cumulative_dry_mass
  }

  excess_pb210 <- stats::approx(
    object$data$cumulative_dry_mass,
    without_errors(object$data$excess_pb210),
    xout = cumulative_dry_mass
  )$y

  # use errors for exact matches of cumulative_dry_mass to the original
  original_matches <- match(cumulative_dry_mass, object$data$cumulative_dry_mass)
  excess_pb210_sd <- extract_errors(object$data$excess_pb210)[original_matches]
  excess_pb210 <- with_errors(excess_pb210, excess_pb210_sd)

  if (inherits(object$inventory, "inventory_calculator")) {
    inventory <- predict.inventory_calculator(
      object$inventory,
      cumulative_dry_mass = cumulative_dry_mass,
      excess_pb210 = excess_pb210
    )
    inventory_sd <- extract_errors(inventory)
    inventory <- without_errors(inventory)
  } else {
    inventory <- stats::approx(
      object$data$cumulative_dry_mass,
      without_errors(object$inventory),
      xout = cumulative_dry_mass
    )$y
    inventory_sd <- extract_errors(object$inventory)[original_matches]
  }

  # check inventory
  stopifnot(
    is.numeric(inventory), length(inventory) == length(cumulative_dry_mass),
    # inventory must be decreasing everywhere
    all(diff(without_errors(inventory[is.finite(inventory)])) <= 0)
  )

  inventory <- with_errors(inventory, inventory_sd)

  # resolve the top model
  model_top <- pb210_as_fit(
    object$model_top,
    data = tibble::tibble(cumulative_dry_mass, inventory)
  )

  # the CRS model is the CIC model using inventory instead of concentration
  fit_cic <- pb210_cic(
    cumulative_dry_mass, inventory,
    model_top = model_top,
    decay_constant = object$decay_constant
  )

  ages <- predict.pb210_fit_cic(fit_cic, cumulative_dry_mass)

  # add errors
  has_error <- is.finite(errors(excess_pb210)) & (errors(excess_pb210) > 0)

  # the CRS model lets us estimate the mass accumulation rate directly
  mar <- object$decay_constant * inventory / excess_pb210 / object$core_area

  ages$mar <- without_errors(mar)
  ages$mar_sd <- extract_errors(mar)
  ages$mar_sd[!has_error] <- NA_real_

  ages$inventory <- without_errors(inventory)
  ages$inventory_sd <- extract_errors(inventory)

  ages
}
