
#' Apply the Constant Rate of Supply or Constant Initial Concentration model
#'
#' @param cumulative_dry_mass The cumulative dry mass of the core (in kg), starting at the
#'   surface sample and including all samples in the core.
#'   These must be greater than 0 and in increasing order.
#' @param excess An excess (non-erosional) lead-210 specific activity (in Bq/kg)
#'   for samples where this was measured, and NA where lead-210 was not measured. Use
#'   [errors::set_errors()] to use automatic error propogation.
#' @param inventory The cumulative excess lead-210 activity (in Bq), starting at the bottom
#'   of the core. By default, this is estimated by the default [pb210_inventory_calculator()].
#' @param model_top A fit object, such as one generated by [pb210_fit_exponential()], or a
#'   constant specifying the surface concentration (CIC model) or inventory (CRS model).
#'   The choice of this value has considerable impact on young dates.
#' @param core_area The internal area of the corer (in m^2^). This can be calculated
#'   from an internal diameter using [pb210_core_area()].
#' @param decay_constant The decay contstant for lead-210 (in 1/years). This is an argument
#'   rather than a constant because we have found that different spreadsheets in the wild
#'   use different decay constants. See [pb210_decay_constant()].
#' @param object A fit object generated by [pb210_crs()] or [pb210_cic()].
#' @param ... Unused.
#'
#' @references
#' Appleby, P.G., and Oldfield, F. 1983. The assessment of ^210^Pb data from sites with
#' varying sediment accumulation rates.
#' Hydrobiologia, 103: 29–35. doi:10.1007/BF00028424.
#'
#' Appleby, P.G., and Oldfield, F. 1978. The calculation of lead-210 dates assuming a
#' constant rate of supply of unsupported ^210^Pb to the sediment.
#' CATENA, 5: 1–8. doi:10.1016/S0341-8162(78)80002-2.
#'
#' @return `predict()` methods return a tibble with (at least)
#' components `age` and `age_sd` (both in years).
#'   CRS model `predict()` function output also contains `inventory`, `inventory_sd`,
#'   `mar` and `mar_sd` (in kg / m^2^ / year).
#' @export
#'
#' @examples
#' # simulate a core
#' core <- pb210_simulate_core() %>%
#'   pb210_simulate_counting()
#'
#' # calculate ages using the CIC model
#' cic <- pb210_cic(
#'   pb210_cumulative_mass(core$slice_mass, position = 0.5),
#'   set_errors(
#'     core$activity_estimate,
#'     core$activity_se
#'   )
#' )
#'
#' predict(cic)
#'
#' # calculate ages using the CRS model
#' crs <- pb210_crs(
#'   pb210_cumulative_mass(core$slice_mass),
#'   set_errors(
#'     core$activity_estimate,
#'     core$activity_se
#'   )
#' )
#'
#' predict(crs)
#'
pb210_cic <- function(cumulative_dry_mass, excess,
                      model_top = ~pb210_fit_exponential(..1, ..2),
                      decay_constant = pb210_decay_constant()) {
  check_mass_and_activity(cumulative_dry_mass, without_errors(excess))
  stopifnot(
    is.numeric(decay_constant), length(decay_constant) == 1,
    without_errors(decay_constant) > 0
  )

  # validate the top model fit, combine errors for pb210
  model_top <- pb210_as_fit(model_top)

  # capture relevant info
  structure(
    list(
      data = tibble::tibble(
        cumulative_dry_mass = cumulative_dry_mass,
        excess = with_errors(excess)
      ),
      model_top = model_top,
      decay_constant = with_errors(decay_constant)
    ),
    class = c("pb210_fit_cic", "pb210_fit")
  )
}

#' @rdname pb210_cic
#' @export
pb210_crs <- function(cumulative_dry_mass, excess,
                      inventory = pb210_inventory_calculator(),
                      model_top = ~pb210_fit_exponential(..1, ..2),
                      core_area = pb210_core_area(),
                      decay_constant = pb210_decay_constant()) {

  check_mass_and_activity(cumulative_dry_mass, without_errors(excess))
  stopifnot(
    inherits(inventory, "inventory_calculator") || is.numeric(inventory),
    length(core_area) == 1, is.numeric(core_area),
    length(decay_constant) == 1, is.numeric(decay_constant)
  )

  if (is.numeric(inventory)) {
    stopifnot(length(inventory) == length(cumulative_dry_mass))
    inventory <- with_errors(inventory)
  }

  # capture relevant info
  structure(
    list(
      data = tibble::tibble(
        cumulative_dry_mass = cumulative_dry_mass,
        excess = with_errors(excess)
      ),
      # inventory could be an inventory calculator
      inventory = inventory,
      model_top = pb210_as_fit(model_top),
      core_area = with_errors(core_area),
      decay_constant = with_errors(decay_constant)
    ),
    class = c("pb210_fit_crs", "pb210_fit")
  )
}

#' @rdname pb210_cic
#' @export
predict.pb210_fit_cic <- function(object, cumulative_dry_mass = NULL, ...) {
  if (is.null(cumulative_dry_mass)) {
    cumulative_dry_mass <- object$data$cumulative_dry_mass
  }

  excess <- approx_error(
    object$data$cumulative_dry_mass,
    object$data$excess,
    xout = cumulative_dry_mass
  )

  # resolve the top model
  model_top <- pb210_as_fit(
    object$model_top,
    data = tibble::tibble(cumulative_dry_mass, excess)
  )
  surface_excess <- with_errors(stats::predict(model_top, tibble::tibble(x = 0)))

  # calculate ages
  age <- with_errors(1) / object$decay_constant * log(surface_excess / excess)
  age_sd <- extract_errors(age)
  has_error <- is.finite(errors(excess)) & (errors(excess) > 0)
  age_sd[!has_error] <- NA_real_

  tibble::tibble(
    age = without_errors(age),
    age_sd = age_sd
  )
}

#' @rdname pb210_cic
#' @export
predict.pb210_fit_crs <- function(object, cumulative_dry_mass = NULL, ...) {
  if (is.null(cumulative_dry_mass)) {
    cumulative_dry_mass <- object$data$cumulative_dry_mass
  }

  excess <- approx_error(
    object$data$cumulative_dry_mass,
    object$data$excess,
    xout = cumulative_dry_mass
  )

  if (inherits(object$inventory, "inventory_calculator")) {
    inventory <- predict.inventory_calculator(
      object$inventory,
      cumulative_dry_mass = cumulative_dry_mass,
      excess = excess
    )
  } else {
    inventory <- approx_error(
      object$data$cumulative_dry_mass,
      object$inventory,
      xout = cumulative_dry_mass
    )
  }

  # check inventory
  stopifnot(
    is.numeric(inventory), length(inventory) == length(cumulative_dry_mass),
    # inventory must be decreasing everywhere
    all(diff(without_errors(inventory[is.finite(inventory)])) <= 0)
  )

  # resolve the top model
  model_top <- pb210_as_fit(
    object$model_top,
    data = tibble::tibble(cumulative_dry_mass, inventory)
  )

  # the CRS model is the CIC model using inventory instead of concentration
  fit_cic <- pb210_cic(
    cumulative_dry_mass, inventory,
    model_top = model_top,
    decay_constant = object$decay_constant
  )

  ages <- predict.pb210_fit_cic(fit_cic, cumulative_dry_mass)

  # add errors
  has_error <- is.finite(errors(excess)) & (errors(excess) > 0)

  # the CRS model lets us estimate the mass accumulation rate directly
  mar <- object$decay_constant * inventory / excess / object$core_area

  ages$mar <- without_errors(mar)
  ages$mar_sd <- extract_errors(mar)
  ages$mar_sd[!has_error] <- NA_real_

  ages$inventory <- without_errors(inventory)
  ages$inventory_sd <- extract_errors(inventory)

  ages
}
