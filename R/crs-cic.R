
#' Apply the Constant Rate of Supply or Constant Initial Concentration model
#'
#' @param cumulative_dry_mass The cumulative dry mass of the core (in kg), starting at the
#'   surface sample and including all samples in the core.
#'   These must be greater than 0 and in increasing order.
#' @param excess_pb210 An excess (non-erosional) lead-210 specific activity (in Bq/kg)
#'   for samples where this was measured, and NA where lead-210 was not measured.
#' @param excess_pb210_sd The standard error of the excess lead-210 specific activity (in Bq/kg).
#'   Can be NA if error is not known.
#' @param inventory The cumulative excess lead-210 activity (in Bq), starting at the bottom
#'   of the core. By default, this is estimated by [pb210_inventory()].
#' @param model_top A fit object, such as one generated by [pb210_fit_exponential()], or a
#'   constant specifying the surface concentration (CIC model) or inventory (CRS model).
#'   The choice of this value has considerable impact on young dates.
#' @param core_area The internal area of the corer (in m^2^). This can be calculated
#'   from an internal diameter using [pb210_core_area()].
#' @param decay_constant The decay contstant for lead-210 (in 1/years). This is an argument
#'   rather than a constant because we have found that different spreadsheets in the wild
#'   use different decay constants. See [pb210_decay_constant()].
#'
#' @references
#' Appleby, P.G., and Oldfield, F. 1983. The assessment of ^210^Pb data from sites with
#' varying sediment accumulation rates.
#' Hydrobiologia, 103: 29â€“35. doi:10.1007/BF00028424.
#'
#' @return A table with (at least) components `age` and `age_sd` (both in years).
#'   CRS model output also contains `mar` and `mar_sd` (in kg / m^2^ / year).
#' @export
#'
pb210_age_cic <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
                          model_top = pb210_fit_exponential(cumulative_dry_mass, excess_pb210),
                          decay_constant = pb210_decay_constant()) {
  check_mass_and_activity(cumulative_dry_mass, without_errors(excess_pb210), excess_pb210_sd)
  stopifnot(
    is.numeric(decay_constant), length(decay_constant) == 1,
    without_errors(decay_constant) > 0
  )

  # estimate the surface pb210 value
  model_top <- pb210_as_fit(model_top)
  surface_excess_pb210 <- stats::predict(model_top, tibble::tibble(x = 0))

  # assign errors
  excess_pb210 <- with_errors(excess_pb210, excess_pb210_sd)
  decay_constant <- with_errors(decay_constant)
  surface_excess_pb210 <- with_errors(surface_excess_pb210)
  has_error <- is.finite(errors(excess_pb210)) & (errors(excess_pb210) > 0)

  # calculate ages
  age <- with_errors(1) / decay_constant * log(surface_excess_pb210 / excess_pb210)
  age_sd <- extract_errors(age)
  age_sd[!has_error] <- NA_real_

  tibble::tibble(
    cumulative_dry_mass,
    excess_pb210 = without_errors(excess_pb210),
    excess_pb210_sd,
    age = without_errors(age),
    age_sd = age_sd
  )
}

#' @rdname pb210_age_cic
#' @export
pb210_age_crs <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
                          inventory = pb210_inventory(cumulative_dry_mass, excess_pb210, excess_pb210_sd),
                          model_top = pb210_fit_exponential(cumulative_dry_mass, inventory),
                          core_area = pb210_core_area(),
                          decay_constant = pb210_decay_constant()) {

  check_mass_and_activity(cumulative_dry_mass, without_errors(excess_pb210), excess_pb210_sd)
  stopifnot(
    is.numeric(inventory), length(inventory) == length(cumulative_dry_mass),
    length(core_area) == 1, is.numeric(core_area),
    length(decay_constant) == 1, is.numeric(decay_constant),
    # inventory must be decreasing everywhere
    all(diff(without_errors(inventory[is.finite(inventory)])) <= 0)
  )

  # the CRS model is the CIC model using inventory instead of concentration
  tbl <- pb210_age_cic(
    cumulative_dry_mass, inventory,
    model_top = model_top, decay_constant = decay_constant
  )

  # add errors
  decay_constant <- with_errors(decay_constant)
  excess_pb210 <- with_errors(excess_pb210, excess_pb210_sd)
  core_area <- with_errors(core_area)
  inventory <- with_errors(inventory)
  has_error <- is.finite(errors(excess_pb210)) & (errors(excess_pb210) > 0)

  # the CRS model lets us estimate the mass accumulation rate directly

  mar <- decay_constant * inventory / excess_pb210 / core_area
  mar_sd <- extract_errors(mar)
  mar_sd[!has_error] <- NA_real_

  inventory_sd <- extract_errors(inventory)

  tibble::tibble(
    cumulative_dry_mass,
    excess_pb210 = without_errors(excess_pb210),
    excess_pb210_sd,
    inventory = without_errors(inventory),
    inventory_sd = inventory_sd,
    age = tbl$age,
    age_sd = tbl$age_sd,
    mar = without_errors(mar),
    mar_sd = mar_sd
  )
}


#' Calculate cumulative lead-210 activity
#'
#' The cumulative content of lead-210 from the bottom of the core is the basis for the
#' constant rate of supply model, and is a required input to [pb210_age_crs()]. There are
#' as many ways to calculate this as there are people who interpret lead-210 activities.
#' This function models the bottom (below measured lead-210), middle (between measured
#' values of lead-210), and top (above measured lead-210) with separate models to
#' accomodate the variety of methods. By default, lead-210 activity is estimated
#' for samples in which it was not measured by an exponential fit of lead-210
#' activity vs. depth (top and bottom), and by linear interpolation between
#' values (middle).
#'
#' @inheritParams pb210_age_cic
#' @param excess_pb210 An excess lead-210 activity for samples where this was
#'   measured, and NA where lead-210 was not measured. NA values will be estimated using
#'   `model_top`, `model_middle`, and `model_bottom`.
#' @param model_bottom A fit object that will be used to model activities below
#'   the last positive finite lead-210 activity. This must be created using
#'   [pb210_fit_exponential()] in that its `m` and `b` coefficients are used to calculate
#'   the integrated activity below the last positive finite `excess_pb210`.
#' @param n_segments The number of tiny rectangles used to approximate the cumulative
#'   activity between the first and last positive finite lead-210 measurement.
#'
#' @return A vector with [errors::errors()] of cumulative lead-210 activities for each sample
#'   (in Bq).
#' @export
#'
#' @examples
#' fake_mass <- 1:10
#' fake_pb210 <- exp(5 - fake_mass)
#' pb210_inventory(fake_mass, fake_pb210)
#'
#' # compare with known inventory from integrating
#' # exp(5 - fake_mass) to +Inf
#' exp(-1 * fake_mass  + 5) / -(-1)
#'
pb210_inventory <- function(
  cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
  model_bottom = pb210_fit_exponential(cumulative_dry_mass, excess_pb210),
  n_segments = 200L
) {
  check_mass_and_activity(cumulative_dry_mass, without_errors(excess_pb210), excess_pb210_sd)
  stopifnot(
    is.integer(n_segments)
  )

  # separate values and errors for calculation
  excess_pb210_sd <- extract_errors(excess_pb210, excess_pb210_sd)
  excess_pb210 <- without_errors(excess_pb210)

  finite_pb210_indices <- which(
    is.finite(excess_pb210) & (excess_pb210 > 0)
  )

  first_finite_mass <- cumulative_dry_mass[min(finite_pb210_indices)] # kg
  last_finite_mass <- cumulative_dry_mass[max(finite_pb210_indices)] # kg

  # the model exp(m*x + b),
  # integrated, is exp(m*x + b) / m, and because at x = infinity the integral is 0
  # the definite integral from [background] to infinity is exp(m * [background] + b) / -m
  coeffs <- stats::coefficients(model_bottom)
  deep_pb210 <- function(mass) unname(exp(coeffs["m"] * mass  + coeffs["b"]) / -coeffs["m"])

  # in the middle, approximate the cumulative sum as trapezoids using
  # finite values
  finite_pb210 <- excess_pb210[finite_pb210_indices]
  finite_mass <- cumulative_dry_mass[finite_pb210_indices]
  trapezoidal_area <- (finite_pb210[-1] + finite_pb210[-length(finite_pb210)]) / 2 * diff(finite_mass)
  cumulative_mass <- c(rev(cumsum(rev(trapezoidal_area))), 0) + deep_pb210(last_finite_mass)

  inventory_middle_interp <- pb210_fit_interpolator_linear(finite_mass, cumulative_mass)

  # combine the two methods to calculate inventory
  inventory <- ifelse(
    cumulative_dry_mass <= last_finite_mass,
    predict(inventory_middle_interp, tibble::tibble(x = cumulative_dry_mass)),
    deep_pb210(cumulative_dry_mass)
  ) # Bq

  # Zero inventories aren't allowed because they get logged
  inventory[inventory <= 0] <- NA_real_

  # this error propogation is from R. Jack Cornett's spreadsheet, and should
  # be examined with more scrutiny
  pb210_relative_sd <- excess_pb210_sd / excess_pb210
  inventory_sd <- inventory * sqrt(2 * pb210_relative_sd^2 + 0.02^2)

  with_errors(inventory, inventory_sd)
}

#' Calculate excess (unsupported) lead-210
#'
#' @param total_pb210,total_pb210_sd A vector of measured lead-210 specific activities (in Bq/kg) and
#'   associated error. These can have [errors::errors()].
#' @param background_pb210,background_pb210_sd A vector of estimated background
#'   lead-210 specific activity (in Bq/kg) and associated error.
#'
#' @return A vector with [errors::errors()] of the excess lead-210 specific activity.
#' @export
#'
#' @examples
#' core <- pb210_simulate_core(depth_step = rep(1, 30)) %>%
#'   pb210_simulate_counting()
#'
#' pb210_excess(
#'   core$pb210_specific_activity_estimate,
#'   background_pb210 = 10,
#'   core$pb210_specific_activity_sd
#' )
#'
pb210_excess <- function(total_pb210, background_pb210 = 0, total_pb210_sd = NA_real_, background_pb210_sd = NA_real_) {
  excess <- with_errors(total_pb210, total_pb210_sd) -
    with_errors(background_pb210, background_pb210_sd)
  excess[(without_errors(excess) - extract_errors(excess)) <= 0] <- NA_real_
  excess
}


check_mass_and_activity <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_) {
  stopifnot(
    is.numeric(cumulative_dry_mass),
    all(is.finite(cumulative_dry_mass)),
    all(cumulative_dry_mass >= 0),
    all(diff(cumulative_dry_mass) > 0),
    is.numeric(excess_pb210),
    sum(is.finite(excess_pb210) & (excess_pb210 > 0)) >= 3,
    length(cumulative_dry_mass) == length(excess_pb210),
    is.numeric(excess_pb210_sd),
    all(excess_pb210 >= 0, na.rm = TRUE),
    length(excess_pb210_sd) == 1 || length(excess_pb210_sd) == length(cumulative_dry_mass)
  )
}
