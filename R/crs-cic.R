
#' Apply the Constant Rate of Supply or Constant Initial Concentration model
#'
#' @param cumulative_dry_mass The cumulative dry mass of the core (in kg), starting at the
#'   surface sample and including all samples in the core.
#'   These must be greater than 0 and in increasing order.
#' @param excess_pb210 An excess (non-erosional) lead-210 specific activity (in Bq/kg)
#'   for samples where this was measured, and NA where lead-210 was not measured.
#' @param excess_pb210_sd The standard error of the excess lead-210 specific activity (in Bq/kg).
#'   Can be NA if error is not known.
#' @param inventory The cumulative excess lead-210 activity (in Bq), starting at the bottom
#'   of the core. By default, this is estimated by [pb210_inventory()].
#' @param model_top A fit object, such as one generated by [pb210_fit_exponential()], or a
#'   constant specifying the surface concentration (CIC model) or inventory (CRS model).
#'   The choice of this value has considerable impact on young dates.
#' @param core_area The internal area of the corer (in m^2^). This can be calculated
#'   from an internal diameter using [pb210_core_area()].
#' @param decay_constant The decay contstant for lead-210 (in 1/years). This is an argument
#'   rather than a constant because we have found that different spreadsheets in the wild
#'   use different decay constants. See [pb210_decay_constant()].
#'
#' @references
#' Appleby, P.G., and Oldfield, F. 1983. The assessment of ^210^Pb data from sites with
#' varying sediment accumulation rates.
#' Hydrobiologia, 103: 29â€“35. doi:10.1007/BF00028424.
#'
#' @return A table with (at least) components `age` and `age_sd` (both in years).
#'   CRS model output also contains `mar` and `mar_sd` (in kg / m^2^ / year).
#' @export
#'
pb210_age_cic <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
                          model_top = pb210_fit_exponential(cumulative_dry_mass, excess_pb210),
                          decay_constant = pb210_decay_constant()) {

  check_mass_and_activity(cumulative_dry_mass, excess_pb210, excess_pb210_sd)
  stopifnot(
    is.numeric(decay_constant), length(decay_constant) == 1
  )

  # estimate the surface pb210 value
  model_top <- pb210_as_fit(model_top)
  surface_excess_pb210 <- stats::predict(model_top, tibble::tibble(x = 0))

  # calculate relative error of pb210, which we use to calculate the error in age
  # this error propogation was used by R. Jack Cornett in his spreadsheets
  # it likely should be updated
  pb210_relative_sd <- excess_pb210_sd / excess_pb210

  tibble::tibble(
    cumulative_dry_mass,
    excess_pb210,
    excess_pb210_sd,
    age = 1 / decay_constant * log(surface_excess_pb210 / excess_pb210),
    age_sd = .data$age * sqrt(2 * pb210_relative_sd^2)
  )
}

#' @rdname pb210_age_cic
#' @export
pb210_age_crs <- function(cumulative_dry_mass, excess_pb210,
                          inventory = pb210_inventory(cumulative_dry_mass, excess_pb210),
                          excess_pb210_sd = NA_real_,
                          model_top = pb210_fit_exponential(cumulative_dry_mass, inventory),
                          core_area = pb210_core_area(),
                          decay_constant = pb210_decay_constant()) {

  check_mass_and_activity(cumulative_dry_mass, excess_pb210, excess_pb210_sd)
  stopifnot(
    is.numeric(inventory), length(inventory) == length(cumulative_dry_mass),
    length(core_area) == 1, is.numeric(core_area),
    length(decay_constant) == 1, is.numeric(decay_constant)
  )

  # calculate relative error of pb210, which we use to calculate the error in age
  # this error propogation was used by R. Jack Cornett in his spreadsheets
  # it likely should be updated
  pb210_relative_sd <- excess_pb210_sd / excess_pb210
  inventory_sd <- inventory * sqrt(2 * pb210_relative_sd^2)

  # the CRS model is the CIC model using inventory instead of concentration
  tbl <- pb210_age_cic(
    cumulative_dry_mass, inventory, inventory_sd,
    model_top = model_top, decay_constant = decay_constant
  )

  # the CRS lets us estimate the mass accumulation rate directly
  tbl$mar <- decay_constant * inventory / excess_pb210 / core_area
  tbl$mar_sd <- tbl$mar * pb210_relative_sd

  tbl
}


#' Calculate cumulative lead-210 activity
#'
#' The cumulative content of lead-210 from the bottom of the core is the basis for the
#' constant rate of supply model, and is a required input to [pb210_age_crs()]. There are
#' as many ways to calculate this as there are people who interpret lead-210 activities.
#' This function models the bottom (below measured lead-210), middle (between measured
#' values of lead-210), and top (above measured lead-210) with separate models to
#' accomodate the variety of methods. By default, lead-210 activity is estimated
#' for samples in which it was not measured by an exponential fit of lead-210
#' activity vs. depth (top and bottom), and by linear interpolation between
#' values (middle).
#'
#' @inheritParams pb210_age_cic
#' @param excess_pb210 An excess lead-210 activity for samples where this was
#'   measured, and NA where lead-210 was not measured. NA values will be estimated using
#'   `model_top`, `model_middle`, and `model_bottom`.
#' @param model_bottom A fit object that will be used to model activities below
#'   the last positive finite lead-210 activity. This must be created using
#'   [pb210_fit_exponential()] in that its `m` and `b` coefficients are used to calculate
#'   the integrated activity below the last positive finite `excess_pb210`.
#' @param model_middle A fit object that will be used to model activities between
#'   measured finite lead-210 activities.
#' @param n_segments The number of tiny rectangles used to approximate the cumulative
#'   activity between the first and last positive finite lead-210 measurement.
#'
#' @return A vector of cumulative lead-210 activities for each sample in Bq.
#' @export
#'
#' @examples
#' fake_mass <- 1:10
#' fake_pb210 <- exp(5 - fake_mass)
#' pb210_inventory(fake_mass, fake_pb210)
#'
#' # compare with known inventory from integrating
#' # exp(5 - fake_mass) to +Inf
#' exp(-1 * fake_mass  + 5) / -(-1)
#'
pb210_inventory <- function(
  cumulative_dry_mass, excess_pb210,
  model_bottom = pb210_fit_exponential(cumulative_dry_mass, excess_pb210),
  model_middle = pb210_fit_interpolator_linear(cumulative_dry_mass, excess_pb210),
  n_segments = 200L
) {
  check_mass_and_activity(cumulative_dry_mass, excess_pb210)
  stopifnot(
    is.integer(n_segments)
  )

  finite_pb210_indices <- which(
    is.finite(excess_pb210) &
      (excess_pb210 > 0)
  )

  first_finite_mass <- cumulative_dry_mass[min(finite_pb210_indices)] # kg
  last_finite_mass <- cumulative_dry_mass[max(finite_pb210_indices)] # kg

  # the model exp(m*x + b),
  # integrated, is exp(m*x + b) / m, and because at x = infinity the integral is 0
  # the definite integral from [background] to infinity is exp(m * [background] + b) / -m
  coeffs <- stats::coefficients(model_bottom)
  deep_pb210 <- function(mass) unname(exp(coeffs["m"] * mass  + coeffs["b"]) / -coeffs["m"])

  # in the middle, approximate the cumulative sum with a bunch of tiny rectangles
  mass_step <- (last_finite_mass - first_finite_mass) / n_segments # kg
  mass_points <- seq(
    first_finite_mass,
    last_finite_mass - mass_step / 2,
    length.out = n_segments - 1
  ) # kg
  pb210_modeled <- stats::predict(model_middle, tibble::tibble(x = mass_points)) # Bq / kg
  inventory_middle <- rev(cumsum(rev(pb210_modeled))) * mass_step # Bq
  inventory_middle_interp <- pb210_fit_interpolator_linear(
    c(mass_points, last_finite_mass),
    deep_pb210(last_finite_mass) + c(inventory_middle, 0)
  )

  # combine the two methods
  ifelse(
    cumulative_dry_mass >= last_finite_mass,
    predict(inventory_middle_interp, tibble::tibble(x = cumulative_dry_mass)),
    deep_pb210(cumulative_dry_mass)
  )
}

check_mass_and_activity <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_) {
  stopifnot(
    is.numeric(cumulative_dry_mass),
    all(is.finite(cumulative_dry_mass)),
    all(cumulative_dry_mass >= 0),
    all(diff(cumulative_dry_mass) > 0),
    is.numeric(excess_pb210),
    sum(is.finite(excess_pb210) & (excess_pb210 > 0)) >= 3,
    length(cumulative_dry_mass) == length(excess_pb210),
    is.numeric(excess_pb210_sd),
    all(excess_pb210 >= 0, na.rm = TRUE),
    length(excess_pb210_sd) == 1 || length(excess_pb210_sd) == length(cumulative_dry_mass)
  )
}
