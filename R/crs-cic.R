
#' Apply the Constant Rate of Supply or Constant Initial Concentration model
#'
#' @param cumulative_dry_mass The cumulative dry mass of the core (in kg), starting at the
#'   surface sample and including all samples in the core.
#'   These must be greater than 0 and in increasing order.
#' @param excess An excess (non-erosional) lead-210 specific activity (in Bq/kg)
#'   for samples where this was measured, and NA where lead-210 was not measured. Use
#'   [errors::set_errors()] to use automatic error propogation.
#' @param inventory The cumulative excess lead-210 activity (in Bq), starting at the bottom
#'   of the core. By default, this is estimated by the default [pb210_inventory_calculator()].
#'   If specifying a vector of values, ensure  that the surface (0 cumulative mass) value is
#'   specified.
#' @param model_top A fit object, such as one generated by [pb210_fit_exponential()] or a
#'   constant specifying the surface `excess`. The choice of this value has
#'   considerable impact on young dates.
#' @param core_area The internal area of the corer (in m^2^). This can be calculated
#'   from an internal diameter using [pb210_core_area()].
#' @param decay_constant The decay contstant for lead-210 (in 1/years). This is an argument
#'   rather than a constant because we have found that different spreadsheets in the wild
#'   use different decay constants. See [pb210_decay_constant()].
#' @param object A fit object generated by [pb210_crs()] or [pb210_cic()].
#' @param ... Unused.
#'
#' @references
#' Appleby, P.G., and Oldfield, F. 1983. The assessment of ^210^Pb data from sites with
#' varying sediment accumulation rates.
#' Hydrobiologia, 103: 29–35. doi:10.1007/BF00028424.
#'
#' Appleby, P.G., and Oldfield, F. 1978. The calculation of lead-210 dates assuming a
#' constant rate of supply of unsupported ^210^Pb to the sediment.
#' CATENA, 5: 1–8. doi:10.1016/S0341-8162(78)80002-2.
#'
#' @return `predict()` methods return a tibble with (at least)
#' components `age` and `age_sd` (both in years).
#'   CRS model `predict()` function output also contains `inventory`, `inventory_sd`,
#'   `mar` and `mar_sd` (in kg / m^2^ / year).
#' @export
#'
#' @examples
#' # simulate a core
#' core <- pb210_simulate_core() %>%
#'   pb210_simulate_counting()
#'
#' # calculate ages using the CIC model
#' cic <- pb210_cic(
#'   pb210_cumulative_mass(core$slice_mass),
#'   set_errors(
#'     core$activity_estimate,
#'     core$activity_se
#'   )
#' )
#'
#' predict(cic)
#'
#' # calculate ages using the CRS model
#' crs <- pb210_crs(
#'   pb210_cumulative_mass(core$slice_mass),
#'   set_errors(
#'     core$activity_estimate,
#'     core$activity_se
#'   )
#' )
#'
#' predict(crs)
#'
pb210_cic <- function(cumulative_dry_mass, excess,
                      model_top = ~pb210_fit_exponential(..1, ..2),
                      decay_constant = pb210_decay_constant()) {
  check_mass_and_activity(cumulative_dry_mass, without_errors(excess))
  stopifnot(
    is.numeric(decay_constant), length(decay_constant) == 1,
    without_errors(decay_constant) > 0
  )

  # validate the top model fit, combine errors for pb210
  model_top <- pb210_as_fit(model_top)

  # capture relevant info
  structure(
    list(
      data = tibble::tibble(
        cumulative_dry_mass = cumulative_dry_mass,
        excess = excess
      ),
      model_top = model_top,
      decay_constant = decay_constant
    ),
    class = c("pb210_fit_cic", "pb210_fit")
  )
}

#' @rdname pb210_cic
#' @export
pb210_crs <- function(cumulative_dry_mass, excess,
                      inventory = pb210_inventory_calculator(),
                      core_area = pb210_core_area(),
                      decay_constant = pb210_decay_constant()) {

  check_mass_and_activity(cumulative_dry_mass, without_errors(excess))
  stopifnot(
    inherits(inventory, "inventory_calculator") || is.numeric(inventory),
    length(core_area) == 1, is.numeric(core_area),
    length(decay_constant) == 1, is.numeric(decay_constant)
  )

  if (is.numeric(inventory)) {
    stopifnot(length(inventory) == length(cumulative_dry_mass))
  }

  # capture relevant info
  structure(
    list(
      data = tibble::tibble(
        cumulative_dry_mass = cumulative_dry_mass,
        excess = excess
      ),
      # inventory could be an inventory calculator
      inventory = inventory,
      core_area = core_area,
      decay_constant = decay_constant
    ),
    class = c("pb210_fit_crs", "pb210_fit")
  )
}

#' @rdname pb210_cic
#' @export
predict.pb210_fit_cic <- function(object, cumulative_dry_mass = NULL, ...) {
  if (is.null(cumulative_dry_mass)) {
    cumulative_dry_mass <- object$data$cumulative_dry_mass
  }

  # resolve the top model
  model_top <- pb210_as_fit(
    object$model_top,
    data = tibble::tibble(
      cumulative_dry_mass = object$data$cumulative_dry_mass,
      excess = object$data$excess
    )
  )

  surface_excess <- stats::predict(model_top, tibble::tibble(x = 0))

  # it's about 2x faster to do these calculations if we don't have to consider
  # error. this makes a differece during MC simulations
  use_errors <- any(is.finite(extract_errors(object$data$excess)))

  if (use_errors) {
    # interpolate excess for all mass values
    excess <- approx_error(
      object$data$cumulative_dry_mass,
      with_errors(object$data$excess),
      xout = cumulative_dry_mass
    )

    one <- with_errors(1)
    decay_constant <- with_errors(object$decay_constant)
    surface_excess <- with_errors(surface_excess)
    excess <- with_errors(excess)
  } else {
    # interpolate excess for all mass values
    excess <- approx_no_error(
      object$data$cumulative_dry_mass,
      object$data$excess,
      xout = cumulative_dry_mass
    )

    one <- 1
    surface_excess <- without_errors(surface_excess)
    decay_constant <- without_errors(object$decay_constant)
  }

  # calculate ages
  age <- one / decay_constant * log(surface_excess / excess)

  if (use_errors) {
    age_sd <- extract_errors(age)
    has_error <- is.finite(errors(excess)) & (errors(excess) > 0)
    age_sd[!has_error] <- NA_real_
    age <- without_errors(age)
  } else {
    age_sd <- NA_real_
  }

  tibble::tibble(age = age, age_sd = age_sd)
}

#' @rdname pb210_cic
#' @export
predict.pb210_fit_crs <- function(object, cumulative_dry_mass = NULL, ...) {
  if (is.null(cumulative_dry_mass)) {
    cumulative_dry_mass <- object$data$cumulative_dry_mass
  }

  use_errors <- any(is.finite(extract_errors(object$data$excess)))

  if (use_errors) {
    excess_raw <- with_errors(object$data$excess)
    na <- with_errors(NA_real_)
    if (inherits(object$inventory, "inventory_calculator")) {
      inventory_raw <- object$inventory
    } else {
      inventory_raw <- with_errors(object$inventory)
      max_inventory <- with_errors(max(without_errors(inventory_raw), na.rm = TRUE))
    }
  } else {
    excess_raw <- without_errors(object$data$excess)
    na <- NA_real_
    if (inherits(object$inventory, "inventory_calculator")) {
      inventory_raw <- object$inventory
    } else {
      inventory_raw <- without_errors(object$inventory)
      max_inventory <- max(inventory_raw, na.rm = TRUE)
    }
  }

  # need a zero for cumulative dry mass for calculation purposes
  if (0 %in% object$data$cumulative_dry_mass) {
    cumulative_dry_mass_calc <- object$data$cumulative_dry_mass
    excess_calc <- excess_raw
    inventory <- inventory_raw
  } else {
    cumulative_dry_mass_calc <- c(0, cumulative_dry_mass)
    excess_calc <- c(na, excess_raw)
    if (!inherits(inventory_raw, "inventory_calculator")) {
      # this is an issue with manually specified inventories...not possible to specify
      # surface inventory currently (assuming max() for now)
      inventory <- c(max_inventory, inventory_raw)
    } else {
      inventory <- inventory_raw
    }
  }

  if (inherits(inventory, "inventory_calculator")) {
    inventory <- predict.inventory_calculator(
      inventory,
      cumulative_dry_mass = cumulative_dry_mass_calc,
      excess = excess_calc
    )

    # inventory may be introduced by the inventory calculator
    use_errors <- use_errors || any(is.finite(extract_errors(inventory)))
  }

  # check inventory
  stopifnot(
    is.numeric(inventory),
    length(inventory) == length(cumulative_dry_mass_calc),
    # inventory must be decreasing everywhere
    all(diff(without_errors(inventory[is.finite(inventory)])) <= 0)
  )

  # the CRS model is the CIC model using inventory instead of concentration
  fit_cic <- pb210_cic(
    cumulative_dry_mass_calc,
    inventory,
    model_top = without_errors(inventory[1]),
    decay_constant = object$decay_constant
  )

  # now we need to calculate outputs to the length of the the input cumulative_dry_mass
  ages <- predict.pb210_fit_cic(fit_cic, cumulative_dry_mass)

  # the CRS model lets us estimate the mass accumulation rate directly
  if (use_errors) {
    excess <- approx_error(cumulative_dry_mass_calc, excess_calc, cumulative_dry_mass)
    inventory <- approx_error(cumulative_dry_mass_calc, inventory, cumulative_dry_mass)
    has_error <- is.finite(extract_errors(excess)) & (extract_errors(excess) > 0)

    mar <- object$decay_constant * inventory / excess / with_errors(object$core_area)

    ages$mar <- without_errors(mar)
    ages$mar_sd <- extract_errors(mar)
    ages$mar_sd[!has_error] <- NA_real_
  } else {
    excess <- approx_no_error(cumulative_dry_mass_calc, excess_calc, cumulative_dry_mass)
    inventory <- approx_no_error(cumulative_dry_mass_calc, inventory, cumulative_dry_mass)

    ages$mar <- without_errors(object$decay_constant) *
      without_errors(inventory) / without_errors(excess) / object$core_area
    ages$mar_sd <- NA_real_
  }

  ages$inventory <- without_errors(inventory)
  ages$inventory_sd <- extract_errors(inventory)

  ages
}
