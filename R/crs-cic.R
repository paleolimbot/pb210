
#' Apply the Constant Rate of Supply or Constant Initial Concentration model
#'
#' @param cumulative_dry_mass The cumulative dry mass of the core (in kg), starting at the
#'   surface sample and including all samples in the core.
#'   These must be greater than 0 and in increasing order.
#' @param excess_pb210 An excess (non-erosional) lead-210 specific activity (in Bq/kg)
#'   for samples where this was measured, and NA where lead-210 was not measured.
#' @param excess_pb210_sd The standard error of the excess lead-210 specific activity (in Bq/kg).
#'   Can be NA if error is not known.
#' @param inventory The cumulative excess lead-210 activity (in Bq), starting at the bottom
#'   of the core. By default, this is estimated by the default [pb210_inventory_calculator()].
#' @param inventory_sd The standard error of the cumulative excess lead-210 activity (in Bq).
#' @param model_top A fit object, such as one generated by [pb210_fit_exponential()], or a
#'   constant specifying the surface concentration (CIC model) or inventory (CRS model).
#'   The choice of this value has considerable impact on young dates.
#' @param core_area The internal area of the corer (in m^2^). This can be calculated
#'   from an internal diameter using [pb210_core_area()].
#' @param decay_constant The decay contstant for lead-210 (in 1/years). This is an argument
#'   rather than a constant because we have found that different spreadsheets in the wild
#'   use different decay constants. See [pb210_decay_constant()].
#' @param object A fit object generated by [pb210_crs()] or [pb210_cic()]
#' @param ... Unused.
#'
#' @references
#' Appleby, P.G., and Oldfield, F. 1983. The assessment of ^210^Pb data from sites with
#' varying sediment accumulation rates.
#' Hydrobiologia, 103: 29–35. doi:10.1007/BF00028424.
#'
#' Appleby, P.G., and Oldfield, F. 1978. The calculation of lead-210 dates assuming a
#' constant rate of supply of unsupported ^210^Pb to the sediment.
#' CATENA, 5: 1–8. doi:10.1016/S0341-8162(78)80002-2.
#'
#' @return A table with (at least) components `age` and `age_sd` (both in years).
#'   CRS model output also contains `inventory`, `inventory_sd`,
#'   `mar` and `mar_sd` (in kg / m^2^ / year).
#' @export
#'
pb210_cic <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
                      model_top = pb210_fit_exponential(cumulative_dry_mass, excess_pb210),
                      decay_constant = pb210_decay_constant()) {
  check_mass_and_activity(cumulative_dry_mass, without_errors(excess_pb210), excess_pb210_sd)
  stopifnot(
    is.numeric(decay_constant), length(decay_constant) == 1,
    without_errors(decay_constant) > 0
  )

  # validate the top model fit, combine errors for pb210
  model_top <- pb210_as_fit(model_top)

  # capture relevant info
  structure(
    list(
      data = tibble::tibble(
        cumulative_dry_mass = cumulative_dry_mass,
        excess_pb210 = without_errors(!!excess_pb210),
        excess_pb210_sd = extract_errors(!!excess_pb210, !!excess_pb210_sd)
      ),
      model_top = model_top,
      decay_constant = with_errors(decay_constant)
    ),
    class = c("pb210_fit_cic", "pb210_fit")
  )
}

#' @rdname pb210_cic
#' @export
pb210_crs <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
                      inventory = pb210_inventory_calculator(),
                      inventory_sd = NA_real_,
                      model_top = ~pb210_fit_exponential(..1, ..2),
                      core_area = pb210_core_area(),
                      decay_constant = pb210_decay_constant()) {

  check_mass_and_activity(cumulative_dry_mass, without_errors(excess_pb210), excess_pb210_sd)
  stopifnot(
    inherits(inventory, "inventory_calculator") || is.numeric(inventory),
    length(core_area) == 1, is.numeric(core_area),
    length(decay_constant) == 1, is.numeric(decay_constant)
  )

  if (is.numeric(inventory)) {
    stopifnot(length(inventory) == length(cumulative_dry_mass))
    inventory_sd <- extract_errors(inventory, inventory_sd)
    inventory <- without_errors(inventory)
  }

  # capture relevant info
  structure(
    list(
      data = tibble::tibble(
        cumulative_dry_mass = cumulative_dry_mass,
        excess_pb210 = without_errors(!!excess_pb210),
        excess_pb210_sd = extract_errors(!!excess_pb210, !!excess_pb210_sd)
      ),
      # inventory could be an inventory calculator
      inventory = inventory,
      inventory_sd = inventory_sd,
      model_top = pb210_as_fit(model_top),
      core_area = core_area,
      decay_constant = with_errors(decay_constant)
    ),
    class = c("pb210_fit_crs", "pb210_fit")
  )
}

#' @rdname pb210_cic
#' @export
predict.pb210_fit_cic <- function(object, cumulative_dry_mass = NULL, ...) {
  if (is.null(cumulative_dry_mass)) {
    cumulative_dry_mass <- object$data$cumulative_dry_mass
  }

  excess_pb210 <- stats::approx(
    object$data$cumulative_dry_mass,
    object$data$excess_pb210,
    xout = cumulative_dry_mass
  )$y

  # use errors for exact matches of cumulative_dry_mass to the original
  original_matches <- match(cumulative_dry_mass, object$data$cumulative_dry_mass)
  excess_pb210_sd <- object$data$excess_pb210_sd[original_matches]

  # resolve the top model
  model_top <- pb210_as_fit(
    object$model_top,
    data = tibble::tibble(cumulative_dry_mass, excess_pb210, excess_pb210_sd)
  )

  # assign errors
  excess_pb210 <- with_errors(excess_pb210, excess_pb210_sd)
  surface_excess_pb210 <- with_errors(stats::predict(model_top, tibble::tibble(x = 0)))

  # calculate ages
  age <- with_errors(1) / object$decay_constant * log(surface_excess_pb210 / excess_pb210)
  age_sd <- extract_errors(age)
  has_error <- is.finite(errors(excess_pb210)) & (errors(excess_pb210) > 0)
  age_sd[!has_error] <- NA_real_

  tibble::tibble(
    age = without_errors(age),
    age_sd = age_sd
  )
}

#' @rdname pb210_cic
#' @export
predict.pb210_fit_crs <- function(object, cumulative_dry_mass = NULL, ...) {
  if (is.null(cumulative_dry_mass)) {
    cumulative_dry_mass <- object$data$cumulative_dry_mass
  }

  excess_pb210 <- stats::approx(
    object$data$cumulative_dry_mass,
    object$data$excess_pb210,
    xout = cumulative_dry_mass
  )$y

  # use errors for exact matches of cumulative_dry_mass to the original
  original_matches <- match(cumulative_dry_mass, object$data$cumulative_dry_mass)
  excess_pb210_sd <- object$data$excess_pb210_sd[original_matches]

  if (inherits(object$inventory, "inventory_calculator")) {
    inventory <- predict.inventory_calculator(
      object$inventory,
      cumulative_dry_mass = cumulative_dry_mass,
      excess_pb210 = excess_pb210,
      excess_pb210_sd = excess_pb210_sd
    )
    inventory_sd <- extract_errors(inventory)
    inventory <- without_errors(inventory)
  } else {
    inventory <- stats::approx(
      object$data$cumulative_dry_mass,
      object$inventory,
      xout = cumulative_dry_mass
    )$y
    inventory_sd <- object$inventory_sd[original_matches]
  }

  # check inventory
  stopifnot(
    is.numeric(inventory), length(inventory) == length(cumulative_dry_mass),
    # inventory must be decreasing everywhere
    all(diff(without_errors(inventory[is.finite(inventory)])) <= 0)
  )

  # resolve the top model
  model_top <- pb210_as_fit(
    object$model_top,
    data = tibble::tibble(cumulative_dry_mass, excess_pb210 = inventory, excess_pb210_sd = inventory_sd)
  )

  # the CRS model is the CIC model using inventory instead of concentration
  fit_cic <- pb210_cic(
    cumulative_dry_mass, inventory, inventory_sd,
    model_top = model_top, decay_constant = object$decay_constant
  )

  ages <- predict.pb210_fit_cic(fit_cic, cumulative_dry_mass)

  # add errors
  excess_pb210 <- with_errors(excess_pb210, excess_pb210_sd)
  core_area <- with_errors(object$core_area)
  inventory <- with_errors(inventory, inventory_sd)
  has_error <- is.finite(errors(excess_pb210)) & (errors(excess_pb210) > 0)

  # the CRS model lets us estimate the mass accumulation rate directly
  mar <- object$decay_constant * inventory / excess_pb210 / core_area
  mar_sd <- extract_errors(mar)
  mar_sd[!has_error] <- NA_real_

  ages$mar <- without_errors(mar)
  ages$mar_sd <- extract_errors(mar)
  ages$mar_sd[!has_error] <- NA_real_

  ages$inventory <- without_errors(inventory)
  ages$inventory_sd <- extract_errors(inventory)

  ages
}

#' @rdname pb210_cic
#' @export
pb210_age_cic <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
                          model_top = pb210_fit_exponential(cumulative_dry_mass, excess_pb210),
                          decay_constant = pb210_decay_constant()) {
  fit <- pb210_cic(
    cumulative_dry_mass = cumulative_dry_mass,
    excess_pb210 = excess_pb210,
    excess_pb210_sd = excess_pb210_sd,
    model_top = model_top,
    decay_constant = decay_constant
  )

  ages <- predict.pb210_fit_cic(fit)

  tibble::tibble(
    cumulative_dry_mass = fit$data$cumulative_dry_mass,
    excess_pb210 = fit$data$excess_pb210,
    excess_pb210_sd = fit$data$excess_pb210_sd,
    age = ages$age,
    age_sd = ages$age_sd
  )
}

#' @rdname pb210_cic
#' @export
pb210_age_crs <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
                          inventory = pb210_inventory_calculator(),
                          model_top = ~pb210_fit_exponential(..1, ..2),
                          core_area = pb210_core_area(),
                          decay_constant = pb210_decay_constant()) {
  fit <- pb210_crs(
    cumulative_dry_mass = cumulative_dry_mass,
    excess_pb210 = excess_pb210,
    excess_pb210_sd = excess_pb210_sd,
    inventory = inventory,
    model_top = model_top,
    core_area = core_area,
    decay_constant = decay_constant
  )

  ages <- predict.pb210_fit_crs(fit)

  tibble::tibble(
    cumulative_dry_mass = fit$data$cumulative_dry_mass,
    excess_pb210 = fit$data$excess_pb210,
    excess_pb210_sd = fit$data$excess_pb210_sd,
    inventory = ages$inventory,
    inventory_sd = ages$inventory_sd,
    age = ages$age,
    age_sd = ages$age_sd,
    mar = ages$mar,
    mar_sd = ages$mar_sd
  )
}


#' Calculate cumulative lead-210 activity
#'
#' The cumulative content of lead-210 from the bottom of the core is the basis
#' for the constant rate of supply model, and is a required input to
#' [pb210_crs()]. There are as many ways to calculate this as there are people
#' who interpret lead-210 activities. This function models the bottom (below
#' measured lead-210), middle (between measured values of lead-210), and top
#' (above measured lead-210) with separate models to accomodate the variety of
#' methods. By default, lead-210 activity is estimated for samples in which it
#' was not measured by an exponential fit of lead-210 activity vs. depth (top
#' and bottom), and by linear interpolation between values (middle).
#'
#' @inheritParams pb210_cic
#' @param excess_pb210 An excess lead-210 activity for samples where this was
#'   measured, and NA where lead-210 was not measured. NA values will be
#'   estimated using `model_top`, `model_middle`, and `model_bottom`.
#' @param model_top A fit object or constant that will be used to model
#'   activities above the first positive finite lead-210 activity. Use NULL for
#'   the default (use the maximum lead-210 activity). Can also be a
#'   lambda-function of `cumulative_dry_mass`, `excess_pb210`, and
#'   `excess_pb210_sd`.
#' @param model_bottom A fit object that will be used to model activities below
#'   the last positive finite lead-210 activity. This must be created using
#'   [pb210_fit_exponential()] or [pb210_fit_loglinear()] in that the fit's `m`
#'   and `b` coefficients are used to calculate the integrated activity below
#'   the last positive finite `excess_pb210`. Use a constant to specify a custom
#'   deep inventory of lead-210. Use NULL for the default
#'   ([pb210_fit_exponential()]). Can also be a lambda-function of
#'   `cumulative_dry_mass`, `excess_pb210`, and `excess_pb210_sd`.
#' @param object An inventory calculator generated by
#'   [pb210_inventory_calculator()].
#'
#' @return [pb210_inventory()] returns a vector with [errors::errors()] of
#'   cumulative lead-210 activities for each sample (in Bq) that can be passed
#'   as the `inventory` to [pb210_crs()]. [pb210_inventory_calculator()] returns
#'   a fit object that can be used to calculate inventory given an
#'   `cumulative_dry_mass`, `excess_pb210`, and `excess_pb210_sd`.
#' @export
#'
#' @examples
#' fake_mass <- 1:10
#' fake_pb210 <- exp(5 - fake_mass)
#' pb210_inventory(fake_mass, fake_pb210)
#'
#' # compare with known inventory from integrating
#' # exp(5 - fake_mass) to +Inf
#' exp(-1 * fake_mass  + 5) / -(-1)
#'
pb210_inventory <- function(
  cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
  model_top = max(excess_pb210, na.rm = TRUE),
  model_bottom = pb210_fit_exponential(cumulative_dry_mass, excess_pb210)
) {
  fit <- pb210_inventory_calculator(
    model_top = model_top,
    model_bottom = model_bottom
  )

  predict.inventory_calculator(
    fit,
    cumulative_dry_mass = cumulative_dry_mass,
    excess_pb210 = excess_pb210,
    excess_pb210_sd = excess_pb210_sd
  )
}

#' @rdname pb210_inventory
#' @export
pb210_inventory_calculator <- function(model_top = ~max(..2, na.rm = TRUE),
                                       model_bottom = ~pb210_fit_exponential(..1, ..2)) {
  structure(
    list(
      model_top = pb210_as_fit(model_top),
      model_bottom = pb210_as_fit(model_bottom)
    ),
    class = c("inventory_calculator", "pb210_fit")
  )
}

#' @rdname pb210_inventory
#' @export
predict.inventory_calculator <- function(object, cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_,
                                        ...) {
  check_mass_and_activity(cumulative_dry_mass, without_errors(excess_pb210), excess_pb210_sd)

  data <- tibble::tibble(
    cumulative_dry_mass,
    excess_pb210 = without_errors(!!excess_pb210),
    excess_pb210_sd = extract_errors(!!excess_pb210, !!excess_pb210_sd)
  )

  model_bottom <- pb210_as_fit(object$model_bottom, data = data)
  model_top <- pb210_as_fit(object$model_top, data = data)

  finite_pb210_indices <- which(
    is.finite(data$excess_pb210) & (data$excess_pb210 > 0)
  )

  first_finite_mass <- data$cumulative_dry_mass[min(finite_pb210_indices)] # kg
  last_finite_mass <- data$cumulative_dry_mass[max(finite_pb210_indices)] # kg

  # approximate the surface activities first
  data$excess_pb210[data$cumulative_dry_mass < first_finite_mass] <- stats::predict(
    model_top,
    tibble::tibble(x = data$cumulative_dry_mass[data$cumulative_dry_mass < first_finite_mass])
  )

  # recalculate finite indices, so the surface can be used in the trapezoidal approximation
  finite_pb210_indices <- which(
    is.finite(data$excess_pb210) & (data$excess_pb210 > 0)
  )

  # the model exp(m*x + b),
  # integrated, is exp(m*x + b) / m, and because at x = infinity the integral is 0
  # the definite integral from [background] to infinity is exp(m * [background] + b) / -m
  coeffs <- stats::coefficients(model_bottom)
  deep_pb210 <- function(mass) unname(exp(coeffs["m"] * mass  + coeffs["b"]) / -coeffs["m"])

  # in the middle, approximate the cumulative sum as trapezoids using
  # finite values
  finite_pb210 <- data$excess_pb210[finite_pb210_indices]
  finite_mass <- data$cumulative_dry_mass[finite_pb210_indices]
  trapezoidal_area <- (finite_pb210[-1] + finite_pb210[-length(finite_pb210)]) / 2 * diff(finite_mass)
  cumulative_mass <- c(rev(cumsum(rev(trapezoidal_area))), 0) + deep_pb210(last_finite_mass)

  inventory_middle_interp <- pb210_fit_interpolator_linear(finite_mass, cumulative_mass)

  # combine the two methods to calculate inventory
  inventory <- ifelse(
    data$cumulative_dry_mass <= last_finite_mass,
    predict(inventory_middle_interp, tibble::tibble(x = data$cumulative_dry_mass)),
    deep_pb210(data$cumulative_dry_mass)
  ) # Bq

  # Zero inventories aren't allowed because they get logged
  inventory[inventory <= 0] <- NA_real_

  # this error propogation is from R. Jack Cornett's spreadsheet, and should
  # be examined with more scrutiny
  pb210_relative_sd <- data$excess_pb210_sd / data$excess_pb210
  inventory_sd <- inventory * sqrt(2 * pb210_relative_sd^2 + 0.02^2)

  with_errors(inventory, inventory_sd)
}

#' Calculate excess (unsupported) lead-210
#'
#' @param total_pb210,total_pb210_sd A vector of measured lead-210 specific activities (in Bq/kg) and
#'   associated error. These can have [errors::errors()].
#' @param background_pb210,background_pb210_sd A vector of estimated background
#'   lead-210 specific activity (in Bq/kg) and associated error.
#'
#' @return A vector with [errors::errors()] of the excess lead-210 specific activity.
#' @export
#'
#' @examples
#' core <- pb210_simulate_core(depth_step = rep(1, 30)) %>%
#'   pb210_simulate_counting()
#'
#' pb210_excess(
#'   core$pb210_specific_activity_estimate,
#'   background_pb210 = 10,
#'   core$pb210_specific_activity_sd
#' )
#'
pb210_excess <- function(total_pb210, background_pb210 = 0,
                         total_pb210_sd = NA_real_, background_pb210_sd = NA_real_) {
  excess <- with_errors(total_pb210, total_pb210_sd) -
    with_errors(background_pb210, background_pb210_sd)
  excess[(without_errors(excess) - extract_errors(excess)) <= 0] <- NA_real_
  excess
}


check_mass_and_activity <- function(cumulative_dry_mass, excess_pb210, excess_pb210_sd = NA_real_) {
  stopifnot(
    is.numeric(cumulative_dry_mass),
    all(is.finite(cumulative_dry_mass)),
    all(cumulative_dry_mass >= 0),
    all(diff(cumulative_dry_mass) > 0),
    is.numeric(excess_pb210),
    sum(is.finite(excess_pb210) & (excess_pb210 > 0)) >= 3,
    length(cumulative_dry_mass) == length(excess_pb210),
    is.numeric(excess_pb210_sd),
    all(excess_pb210 >= 0, na.rm = TRUE),
    length(excess_pb210_sd) == 1 || length(excess_pb210_sd) == length(cumulative_dry_mass)
  )
}
