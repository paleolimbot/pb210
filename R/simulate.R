
#' Simulate sediment accumulation
#'
#' @param max_age The maximum age of the simulation (years)
#' @param time_step The time to consider in each step (years)
#' @param supply A function such as that generated by [pb210_supply_constant()].
#'   The flux of lead-210 to the surface, in Bq/ m^2^ / year
#' @param mass_accumulation A function such as that generated by [pb210_mass_accumulation_constant()].
#'   Values returned by the function should be in kg / m^2^ / year.
#' @param compressibility A function such as that generated by [pb210_compressibility_constant()].
#'   Values returned by the function should be in 1 / Pa.
#' @param initial_density A function such as that generated by [pb210_density_constant()].
#'   Values returned by the function should be in kg / m^3^.
#' @param decay_constant The decay constant to use (see [pb210_decay_constant()])
#'
#' @return A tibble with components ...
#' @importFrom rlang .data
#' @export
#'
#' @examples
#' pb210_simulate_accumulation()
#'
pb210_simulate_accumulation <- function(mass_accumulation = pb210_mass_accumulation_constant(),
                                        max_age = 500, time_step = 1,
                                        supply = pb210_supply_constant(),
                                        compressibility = pb210_compressibility_constant(),
                                        initial_density = pb210_density_constant(),
                                        decay_constant = pb210_decay_constant()) {
  stopifnot(
    is.numeric(max_age), length(max_age) == 1,
    is.numeric(time_step), length(time_step) == 1, time_step > 0,
    is.numeric(decay_constant), length(decay_constant) == 1, decay_constant > 0
  )

  # all calculations here are for a 1 m^2 section.
  core_area <- 1

  mass_accumulation <- rlang::as_function(mass_accumulation, env = rlang::caller_env())
  supply <- rlang::as_function(supply, env = rlang::caller_env())
  compressibility <- rlang::as_function(compressibility, env = rlang::caller_env())
  initial_density <- rlang::as_function(initial_density, env = rlang::caller_env())

  tbl <- tibble::tibble(
    # ages
    age_top = seq(max_age - time_step, 0, by = -time_step),
    age_bottom = seq(max_age, 0 + time_step, by = -time_step),
    age = (.data$age_top + .data$age_bottom) / 2,

    # initial values
    initial_pb210_content = supply(.data$age) * time_step, # Bq
    slice_mass = mass_accumulation(.data$age) * time_step * core_area, # kg
    compressibility = compressibility(.data$age), # 1/Pa
    initial_density = initial_density(.data$age), # kg / m^3

    # radioactive decay of pb210, normalize to mass
    pb210_specific_activity = .data$initial_pb210_content * exp(-decay_constant * .data$age) / .data$slice_mass, # Bq / kg

    # compression of sediment
    cumulative_mass_above = c(rev(cumsum(rev(.data$slice_mass[-1]))), 0), # kg
    delta_pressure = 9.806 * .data$cumulative_mass_above, # Pa
    relative_volume = 1 - (.data$delta_pressure * .data$compressibility), # unitless (volume / volume at deposition)

    # use density and relative_volume to map slice mass to thickness
    # kg / (kg / m^3) * unitless = m^3
    slice_volume = .data$slice_mass / .data$initial_density * .data$relative_volume,
    slice_density = .data$slice_mass / .data$slice_volume,
    thickness = .data$slice_volume / core_area * 100, # cm
    depth_bottom = rev(cumsum(rev(.data$thickness))),
    depth_top = c(rev(cumsum(rev(.data$thickness[-1]))), 0),
    depth = (.data$depth_top + .data$depth_bottom) / 2
  )

  # return like most core data, backwards in time
  tbl[
    order(tbl$depth),
    c(
      "age", "depth", "pb210_specific_activity", "age_top", "age_bottom",
      "depth_top", "depth_bottom", "slice_mass", "slice_density"
    )
  ]
}


#' Simulate a core of an accumulation
#'
#' @param accumulation An age simulation, created by [pb210_simulate_accumulation()].
#' @param depth_step A vector of depth steps to consider, from the top to the bottom
#'   of the core. There should be one element in the vector for each slice considered.
#' @param core_area The internal area of the core in m^2^.
#'
#' @return A tibble with components ...
#' @export
#'
#' @examples
#' pb210_simulate_core()
#'
pb210_simulate_core <- function(accumulation = pb210_simulate_accumulation(),
                                depth_step = rep(0.5, 60), core_area = pb210_core_area()) {
  stopifnot(
    is.data.frame(accumulation),
    all(
      c("age", "depth_top", "depth_bottom", "pb210_specific_activity", "slice_mass", "slice_density") %in% colnames(accumulation)
    ),
    is.numeric(depth_step), all(depth_step > 0),
    is.numeric(core_area), length(core_area) == 1, core_area > 0
  )

  # all calculations for `accumulation` were for 1 m^2^. slice_mass is the only parameter
  # that depends on this. For the calculations in this resampling to be correct,
  # we need to rescale slice_mass here.
  accumulation$slice_mass <- accumulation$slice_mass * core_area / 1.

  # calculations on accumulation that apply to all of the new depth slices
  accumulation$thickness <- accumulation$depth_bottom - accumulation$depth_top # cm
  accumulation$slice_volume <- accumulation$slice_mass / accumulation$slice_density # m^3

  accumulation$pb210_specific_activity_total <- accumulation$pb210_specific_activity * accumulation$slice_mass # Bq
  accumulation$age_total <- accumulation$age_bottom - accumulation$age_top # yr
  accumulation$sediment_accumulation_rate <- accumulation$age_total / accumulation$thickness # yr

  depths <- tibble::tibble(
    # make new depth slices
    depth_top = c(0, cumsum(depth_step[-1])), # cm
    depth_bottom = cumsum(depth_step), # cm
    depth = (.data$depth_top + .data$depth_bottom) / 2, # cm

    # these attributes are calculated for each new depth slice
    interpolated_attributes = mapply(
      function(top, bottom) {
        # these calculations only apply to this new depth slice
        # they are all of length nrow(accumulation)
        depth_bottom_match <- pmin(bottom, accumulation$depth_bottom) # cm depth
        depth_top_match <- pmax(top, accumulation$depth_top) # cm depth
        depth_in_slice <- pmax(0, depth_bottom_match - depth_top_match) # cm
        proportion_in_slice <- depth_in_slice / accumulation$thickness # proportion
        mass_in_slice <- accumulation$slice_mass * proportion_in_slice # kg

        # could be clearer, but this is an attempt to interpolate the location
        # of the "top" depth based on the intersecting sample from accumulation
        # interpolated_top_ages <- accumulation$age_top + (accumulation$depth_top - top) *
        #   accumulation$sediment_accumulation_rate
        # interpolated_bottom_ages <- accumulation$age_top + (accumulation$depth_top - bottom) *
        #   accumulation$sediment_accumulation_rate
        # intersects_top <- (proportion_in_slice > 0) & (accumulation$depth_top <= top)
        # intersects_bottom <- (proportion_in_slice > 0) & (accumulation$depth_bottom >= bottom)

        # return a 1-row tibble of summary values
        tibble::tibble(
          slice_mass = sum(mass_in_slice),
          pb210_specific_activity = sum(accumulation$pb210_specific_activity_total * proportion_in_slice) / .data$slice_mass,
          # age_top = interpolated_top_ages[intersects_top][1],
          # age_bottom = interpolated_bottom_ages[intersects_bottom][1],
          age = stats::weighted.mean(accumulation$age, mass_in_slice),
          slice_volume = (bottom - top) / 100 * core_area,
          slice_density = .data$slice_mass / .data$slice_volume
        )
      },
      .data$depth_top, .data$depth_bottom,
      SIMPLIFY = FALSE
    )
  )

  # interpolate age_top and age_bottom using stats::approx
  known_depths <- c(0, accumulation$depth_bottom)
  known_ages <- c(0, accumulation$age_bottom)
  depths$age_top <- stats::approx(known_depths, known_ages, depths$depth_top)$y
  depths$age_bottom <- stats::approx(known_depths, known_ages, depths$depth_bottom)$y

  tbl <- tibble::as_tibble(
    cbind(
      depths[c("depth_top", "depth_bottom", "depth", "age_top", "age_bottom")],
      do.call(rbind, depths$interpolated_attributes)
    )
  )

  # the same format as the pb210_simulate_accumulation()
  tbl[
    order(tbl$depth),
    c(
      "age", "depth", "pb210_specific_activity", "age_top", "age_bottom",
      "depth_top", "depth_bottom", "slice_mass", "slice_density"
    )
  ]
}

#' Parameter generators for lead-210 supply
#'
#' @param value An flux of lead 210, in Bq / m^2^ / year.
#'
#' @return A function of a single parameter, `age`, which is a (decreasing) vector of ages.
#' @export
#'
#' @references
#' Appleby, P.G. 2008. Three decades of dating recent sediments by fallout
#' radionuclides: a review. The Holocene, 18: 83â€“93. doi:10.1177/0959683607085598.
#'
#' @examples
#' ages <- 150:0
#'
pb210_supply_constant <- function(value = 100)  {
  force(value)
  function(age) {
    value
  }
}


#' Parameter generators for mass accumulation rates
#'
#' @param value,mean,initial An accumulation rate, in kg / m2 / year.
#' @param sd For random normal accumulation rates, the standard deviation
#' @param mean_slope,sd_slope The mean and standard deviation of the change in
#'   slope, in kg / m2 / year / year
#'
#' @return A function of a single parameter, `age`, which is a (decreasing) vector of ages.
#' @export
#'
#' @examples
#' age_compare <- tibble::tibble(
#'   ages = 150:0,
#'   constant = pb210_mass_accumulation_constant()(ages),
#'   rnorm = pb210_mass_accumulation_rnorm()(ages),
#'   rnorm_trend = pb210_mass_accumulation_rnorm_trend()(ages)
#' )
#'
pb210_mass_accumulation_constant <- function(value = 0.150)  {
  force(value)
  function(age) {
    value
  }
}

#' @rdname pb210_mass_accumulation_constant
#' @export
pb210_mass_accumulation_rnorm <- function(mean = 0.150, sd = 0.020) {
  force(mean)
  force(sd)
  function(age) {
    stats::rnorm(length(age), mean = 150, sd = 20)
  }
}

#' @rdname pb210_mass_accumulation_constant
#' @export
pb210_mass_accumulation_rnorm_trend <- function(initial = 0.150, mean_slope = 0, sd_slope = 0.005) {
  force(initial)
  force(mean_slope)
  force(sd_slope)
  function(age) {
    delta_accumulation <- stats::rnorm(
      length(age) - 1,
      mean = -diff(age) * mean_slope,
      sd = -diff(age) * sd_slope
    )

    cumsum(c(initial, delta_accumulation))
  }
}

#' Parameter generators for density values
#'
#' Note that this refers to dry density at the time of deposition.
#'
#' @param value A density at the time of deposition, in kg / m3
#'
#' @return A function of a single parameter, `age`, which is a (decreasing) vector of ages.
#' @export
#'
#' @examples
#' ages <- 150:0
#' pb210_density_constant()(ages)
#'
pb210_density_constant <- function(value = 150)  {
  force(value)
  function(age) {
    value
  }
}

#' Parameter generators for compressibility
#'
#' Note that this refers to compressibility at the time of deposition.
#'
#' @param value A compressibility at the time of deposition, in 1/Pa.
#'   Higher values (closer to 0) indicate a higher propensity for the material
#'   to be compressed.
#'
#' @return A function of a single parameter, `age`, which is a (decreasing) vector of ages.
#' @export
#'
#' @examples
#' ages <- 150:0
#' pb210_compressibility_constant()(ages)
#'
pb210_compressibility_constant <- function(value = 1e-3)  {
  force(value)
  function(age) {
    value
  }
}
