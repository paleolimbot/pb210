
#' Calculate cumulative lead-210 activity
#'
#' The cumulative content of lead-210 from the bottom of the core is the basis
#' for the constant rate of supply model, and is a required input to
#' [pb210_crs()]. There are as many ways to calculate this as there are people
#' who interpret lead-210 activities. This function models the bottom (below
#' measured lead-210), middle (between measured values of lead-210), and top
#' (above measured lead-210) with separate models to accomodate the variety of
#' methods. By default, lead-210 activity is estimated for samples in which it
#' was not measured by an exponential fit of lead-210 activity vs. depth (top
#' and bottom), and by linear interpolation between values (middle).
#'
#' @inheritParams pb210_cic
#' @param excess An excess lead-210 activity for samples where this was
#'   measured, and NA where lead-210 was not measured. NA values will be
#'   estimated using `model_top`, `model_middle`, and `model_bottom`.
#' @param model_top A fit object or constant that will be used to model
#'   activities above the first positive finite lead-210 activity. Use NULL for
#'   the default (use the maximum lead-210 activity). Can also be a
#'   lambda-function of `cumulative_dry_mass`, `excess`, and
#'   `excess_sd`.
#' @param model_bottom A fit object that will be used to model activities below
#'   the last positive finite lead-210 activity. This must be created using
#'   [pb210_fit_exponential()] or [pb210_fit_loglinear()] in that the fit's `m`
#'   and `b` coefficients are used to calculate the integrated activity below
#'   the last positive finite `excess`. Use a constant to specify a custom
#'   deep inventory of lead-210. Use NULL for the default
#'   ([pb210_fit_exponential()]). Can also be a lambda-function of
#'   `cumulative_dry_mass`, `excess`, and `excess_sd`.
#' @param object An inventory calculator generated by
#'   [pb210_inventory_calculator()].
#'
#' @return [pb210_inventory()] returns a vector with [errors::errors()] of
#'   cumulative lead-210 activities for each sample (in Bq) that can be passed
#'   as the `inventory` to [pb210_crs()]. [pb210_inventory_calculator()] returns
#'   a fit object that can be used to calculate inventory given an
#'   `cumulative_dry_mass`, `excess`, and `excess_sd`.
#' @export
#'
#' @examples
#' fake_mass <- 1:10
#' fake_pb210 <- exp(5 - fake_mass)
#' pb210_inventory(fake_mass, fake_pb210)
#'
#' # compare with known inventory from integrating
#' # exp(5 - fake_mass) to +Inf
#' exp(-1 * fake_mass  + 5) / -(-1)
#'
pb210_inventory <- function(cumulative_dry_mass, excess,
                            model_top = max(excess, na.rm = TRUE),
                            model_bottom = pb210_fit_exponential(cumulative_dry_mass, excess)) {
  fit <- pb210_inventory_calculator(
    model_top = model_top,
    model_bottom = model_bottom
  )

  predict.inventory_calculator(
    fit,
    cumulative_dry_mass = cumulative_dry_mass,
    excess = excess
  )
}

#' @rdname pb210_inventory
#' @export
pb210_inventory_calculator <- function(model_top = ~max(..2, na.rm = TRUE),
                                       model_bottom = ~pb210_fit_exponential(..1, ..2)) {
  structure(
    list(
      model_top = pb210_as_fit(model_top),
      model_bottom = pb210_as_fit(model_bottom)
    ),
    class = c("inventory_calculator", "pb210_fit")
  )
}

#' @rdname pb210_inventory
#' @export
predict.inventory_calculator <- function(object, cumulative_dry_mass, excess, ...) {
  check_mass_and_activity(cumulative_dry_mass, without_errors(excess))

  # model bottom/top functions expect errors as input
  data <- tibble::tibble(cumulative_dry_mass, excess = with_errors(excess))
  model_bottom <- pb210_as_fit(object$model_bottom, data = data)
  model_top <- pb210_as_fit(object$model_top, data = data)

  # the rest of this function needs errors separate from values
  data$excess_sd <- extract_errors(excess)
  data$excess <-  without_errors(data$excess)

  finite_pb210_indices <- which(
    is.finite(data$excess) & (data$excess > 0)
  )

  first_finite_mass <- data$cumulative_dry_mass[min(finite_pb210_indices)] # kg
  last_finite_mass <- data$cumulative_dry_mass[max(finite_pb210_indices)] # kg

  # approximate the surface activities first
  data$excess[data$cumulative_dry_mass < first_finite_mass] <- stats::predict(
    model_top,
    tibble::tibble(x = data$cumulative_dry_mass[data$cumulative_dry_mass < first_finite_mass])
  )

  # recalculate finite indices, so the surface can be used in the trapezoidal approximation
  finite_pb210_indices <- which(
    is.finite(data$excess) & (data$excess > 0)
  )

  # the model exp(m*x + b),
  # integrated, is exp(m*x + b) / m, and because at x = infinity the integral is 0
  # the definite integral from [background] to infinity is exp(m * [background] + b) / -m
  coeffs <- stats::coefficients(model_bottom)
  deep_pb210 <- function(mass) unname(exp(coeffs["m"] * mass  + coeffs["b"]) / -coeffs["m"])

  # in the middle, approximate the cumulative sum as trapezoids using
  # finite values
  finite_pb210 <- data$excess[finite_pb210_indices]
  finite_mass <- data$cumulative_dry_mass[finite_pb210_indices]
  trapezoidal_area <- (finite_pb210[-1] + finite_pb210[-length(finite_pb210)]) / 2 * diff(finite_mass)
  cumulative_mass <- c(rev(cumsum(rev(trapezoidal_area))), 0) + deep_pb210(last_finite_mass)

  inventory_middle_interp <- pb210_fit_interpolator_linear(finite_mass, cumulative_mass)

  # combine the two methods to calculate inventory
  inventory <- ifelse(
    data$cumulative_dry_mass <= last_finite_mass,
    predict(inventory_middle_interp, tibble::tibble(x = data$cumulative_dry_mass)),
    deep_pb210(data$cumulative_dry_mass)
  ) # Bq

  # Zero inventories aren't allowed because they get logged
  inventory[inventory <= 0] <- NA_real_

  # this error propogation is from R. Jack Cornett's spreadsheet, and should
  # be examined with more scrutiny
  pb210_relative_sd <- data$excess_sd / data$excess
  inventory_sd <- inventory * sqrt(2 * pb210_relative_sd^2 + 0.02^2)

  with_errors(inventory, inventory_sd)
}
